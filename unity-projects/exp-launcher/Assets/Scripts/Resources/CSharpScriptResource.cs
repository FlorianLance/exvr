/*******************************************************************************
** exvr-exp                                                                   **
** No license (to be defined)                                                 **
** Copyright (c) [2018] [Florian Lance][EPFL-LNCO]                            **
********************************************************************************/

// system
using System;
using System.Reflection;
using System.CodeDom.Compiler;

namespace Ex{

    public class CSharpScriptResource : ResourceFile{

        private static Assembly m_compiledAssembly = null; // compiled assembly generated by all resource csharp scripts

        public CSharpScriptResource(int key, string alias, string path) : base(key, alias, path) {
        }

        public static Assembly get_compiled_assembly() {
            return m_compiledAssembly;
        }

        public static Type get_type_from_compiled_assembly(string typeName) {
            return m_compiledAssembly.GetType(typeName);
        }

        public static Assembly compile_assembly_from_scripts_files(string[] files) {

            //GC.Collect(); // collects all unused memory
            //GC.WaitForPendingFinalizers(); // wait until GC has finished its work
            //GC.Collect();
            m_compiledAssembly = null;
            if (files.Length == 0) {
                return m_compiledAssembly;
            }

            Modified.Mono.CSharp.CSharpCodeCompiler provider = new Modified.Mono.CSharp.CSharpCodeCompiler();
            var param = new CompilerParameters();

            // add assemblies
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies()) {
                if (assembly.GetName().Name != "Microsoft.GeneratedCode"
                    && assembly.GetName().Name != "Anonymously Hosted DynamicMethods Assembly") {
                    param.ReferencedAssemblies.Add(assembly.Location);
                }
            }
            
            param.GenerateExecutable = false;
            
            if (ExVR.GuiSettings().csharpDebugInfo) {
                // for having line/col during exceptions
                param.GenerateInMemory = false;
                param.IncludeDebugInformation = true;
            } else {
                // faster?
                param.GenerateInMemory = true;
                param.IncludeDebugInformation = false;
            }
            
            // no warnign as errors
            param.TreatWarningsAsErrors = false;

            // Compile the source            
            CompilerResults result = null;
            try {
                result = provider.CompileAssemblyFromFileBatch(param, files);
            } catch (Exception ex) {
                ExVR.Log().error(string.Format("[COMPILER] Cannot compile csharp scripts files: {0}", ex.Message), false);
            }

            if (result != null) {
                foreach (CompilerError error in result.Errors) {

                    string errorMsg = string.Format("[COMPILER] Compilation {0} {1} : \"{2}\" from file {3} at line {4} and column {5}",
                        error.IsWarning ? "warning " : "error ",
                        error.ErrorNumber,
                        error.ErrorText,
                        error.FileName,
                        error.Line,
                        error.Column
                    );

                    if (error.IsWarning) {
                        ExVR.Log().warning(errorMsg, false);
                    } else {
                        ExVR.Log().error(errorMsg, false);
                        return null;
                    }
                }
            } else {
                ExVR.Log().error("[COMPILER] CompileAssemblyFromFile crash", false);
                return null;
            }

            return m_compiledAssembly = result.CompiledAssembly;
        }
    }
}